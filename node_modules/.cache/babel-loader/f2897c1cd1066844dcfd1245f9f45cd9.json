{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Administrador\\\\Desktop\\\\pro01\\\\eth_swap-6-sell-tokens-fe\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Administrador\\\\Desktop\\\\pro01\\\\eth_swap-6-sell-tokens-fe\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\Administrador\\\\Desktop\\\\pro01\\\\eth_swap-6-sell-tokens-fe\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrador\\\\Desktop\\\\pro01\\\\eth_swap-6-sell-tokens-fe\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return a;\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = __getOwnPropSymbols(source)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return target;\n}; // src/index.tsx\n\n\nimport React from \"react\"; // src/third-party/qrcodegen/index.ts\n\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */\n\nvar qrcodegen;\n\n(function (qrcodegen2) {\n  var _QrCode =\n  /*#__PURE__*/\n  function () {\n    /*-- Constructor (low level) and fields --*/\n    // Creates a new QR Code with the given version number,\n    // error correction level, data codeword bytes, and mask number.\n    // This is a low-level API that most users should not use directly.\n    // A mid-level API is the encodeSegments() function.\n    function _QrCode(version, errorCorrectionLevel, dataCodewords, msk) {\n      _classCallCheck(this, _QrCode);\n\n      this.version = version;\n      this.errorCorrectionLevel = errorCorrectionLevel; // The modules of this QR Code (false = light, true = dark).\n      // Immutable after constructor finishes. Accessed through getModule().\n\n      this.modules = []; // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\n      this.isFunction = [];\n      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError(\"Version value out of range\");\n      if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n      this.size = version * 4 + 17;\n      var row = [];\n\n      for (var i = 0; i < this.size; i++) {\n        row.push(false);\n      }\n\n      for (var _i = 0; _i < this.size; _i++) {\n        this.modules.push(row.slice());\n        this.isFunction.push(row.slice());\n      }\n\n      this.drawFunctionPatterns();\n      var allCodewords = this.addEccAndInterleave(dataCodewords);\n      this.drawCodewords(allCodewords);\n\n      if (msk == -1) {\n        var minPenalty = 1e9;\n\n        for (var _i2 = 0; _i2 < 8; _i2++) {\n          this.applyMask(_i2);\n          this.drawFormatBits(_i2);\n          var penalty = this.getPenaltyScore();\n\n          if (penalty < minPenalty) {\n            msk = _i2;\n            minPenalty = penalty;\n          }\n\n          this.applyMask(_i2);\n        }\n      }\n\n      assert(0 <= msk && msk <= 7);\n      this.mask = msk;\n      this.applyMask(msk);\n      this.drawFormatBits(msk);\n      this.isFunction = [];\n    }\n    /*-- Static factory functions (high level) --*/\n    // Returns a QR Code representing the given Unicode text string at the given error correction level.\n    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n    // ecl argument if it can be done without increasing the version.\n\n\n    _createClass(_QrCode, [{\n      key: \"getModule\",\n\n      /*-- Accessor methods --*/\n      // Returns the color of the module (pixel) at the given coordinates, which is false\n      // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n      // If the given coordinates are out of bounds, then false (light) is returned.\n      value: function getModule(x, y) {\n        return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n      } // Modified to expose modules for easy access\n\n    }, {\n      key: \"getModules\",\n      value: function getModules() {\n        return this.modules;\n      }\n      /*-- Private helper methods for constructor: Drawing function modules --*/\n      // Reads this object's version field, and draws and marks all function modules.\n\n    }, {\n      key: \"drawFunctionPatterns\",\n      value: function drawFunctionPatterns() {\n        for (var i = 0; i < this.size; i++) {\n          this.setFunctionModule(6, i, i % 2 == 0);\n          this.setFunctionModule(i, 6, i % 2 == 0);\n        }\n\n        this.drawFinderPattern(3, 3);\n        this.drawFinderPattern(this.size - 4, 3);\n        this.drawFinderPattern(3, this.size - 4);\n        var alignPatPos = this.getAlignmentPatternPositions();\n        var numAlign = alignPatPos.length;\n\n        for (var _i3 = 0; _i3 < numAlign; _i3++) {\n          for (var j = 0; j < numAlign; j++) {\n            if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);\n          }\n        }\n\n        this.drawFormatBits(0);\n        this.drawVersion();\n      } // Draws two copies of the format bits (with its own error correction code)\n      // based on the given mask and this object's error correction level field.\n\n    }, {\n      key: \"drawFormatBits\",\n      value: function drawFormatBits(mask) {\n        var data = this.errorCorrectionLevel.formatBits << 3 | mask;\n        var rem = data;\n\n        for (var i = 0; i < 10; i++) {\n          rem = rem << 1 ^ (rem >>> 9) * 1335;\n        }\n\n        var bits = (data << 10 | rem) ^ 21522;\n        assert(bits >>> 15 == 0);\n\n        for (var _i4 = 0; _i4 <= 5; _i4++) {\n          this.setFunctionModule(8, _i4, getBit(bits, _i4));\n        }\n\n        this.setFunctionModule(8, 7, getBit(bits, 6));\n        this.setFunctionModule(8, 8, getBit(bits, 7));\n        this.setFunctionModule(7, 8, getBit(bits, 8));\n\n        for (var _i5 = 9; _i5 < 15; _i5++) {\n          this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));\n        }\n\n        for (var _i6 = 0; _i6 < 8; _i6++) {\n          this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));\n        }\n\n        for (var _i7 = 8; _i7 < 15; _i7++) {\n          this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));\n        }\n\n        this.setFunctionModule(8, this.size - 8, true);\n      } // Draws two copies of the version bits (with its own error correction code),\n      // based on this object's version field, iff 7 <= version <= 40.\n\n    }, {\n      key: \"drawVersion\",\n      value: function drawVersion() {\n        if (this.version < 7) return;\n        var rem = this.version;\n\n        for (var i = 0; i < 12; i++) {\n          rem = rem << 1 ^ (rem >>> 11) * 7973;\n        }\n\n        var bits = this.version << 12 | rem;\n        assert(bits >>> 18 == 0);\n\n        for (var _i8 = 0; _i8 < 18; _i8++) {\n          var color = getBit(bits, _i8);\n          var a = this.size - 11 + _i8 % 3;\n          var b = Math.floor(_i8 / 3);\n          this.setFunctionModule(a, b, color);\n          this.setFunctionModule(b, a, color);\n        }\n      } // Draws a 9*9 finder pattern including the border separator,\n      // with the center module at (x, y). Modules can be out of bounds.\n\n    }, {\n      key: \"drawFinderPattern\",\n      value: function drawFinderPattern(x, y) {\n        for (var dy = -4; dy <= 4; dy++) {\n          for (var dx = -4; dx <= 4; dx++) {\n            var dist = Math.max(Math.abs(dx), Math.abs(dy));\n            var xx = x + dx;\n            var yy = y + dy;\n            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n          }\n        }\n      } // Draws a 5*5 alignment pattern, with the center module\n      // at (x, y). All modules must be in bounds.\n\n    }, {\n      key: \"drawAlignmentPattern\",\n      value: function drawAlignmentPattern(x, y) {\n        for (var dy = -2; dy <= 2; dy++) {\n          for (var dx = -2; dx <= 2; dx++) {\n            this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n          }\n        }\n      } // Sets the color of a module and marks it as a function module.\n      // Only used by the constructor. Coordinates must be in bounds.\n\n    }, {\n      key: \"setFunctionModule\",\n      value: function setFunctionModule(x, y, isDark) {\n        this.modules[y][x] = isDark;\n        this.isFunction[y][x] = true;\n      }\n      /*-- Private helper methods for constructor: Codewords and masking --*/\n      // Returns a new byte string representing the given data with the appropriate error correction\n      // codewords appended to it, based on this object's version and error correction level.\n\n    }, {\n      key: \"addEccAndInterleave\",\n      value: function addEccAndInterleave(data) {\n        var ver = this.version;\n        var ecl = this.errorCorrectionLevel;\n        if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError(\"Invalid argument\");\n        var numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        var blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n        var rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n        var numShortBlocks = numBlocks - rawCodewords % numBlocks;\n        var shortBlockLen = Math.floor(rawCodewords / numBlocks);\n        var blocks = [];\n\n        var rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n\n        for (var i = 0, k = 0; i < numBlocks; i++) {\n          var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n          k += dat.length;\n\n          var ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n\n          if (i < numShortBlocks) dat.push(0);\n          blocks.push(dat.concat(ecc));\n        }\n\n        var result = [];\n\n        var _loop = function _loop(_i9) {\n          blocks.forEach(function (block, j) {\n            if (_i9 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9]);\n          });\n        };\n\n        for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {\n          _loop(_i9);\n        }\n\n        assert(result.length == rawCodewords);\n        return result;\n      } // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n      // data area of this QR Code. Function modules need to be marked off before this is called.\n\n    }, {\n      key: \"drawCodewords\",\n      value: function drawCodewords(data) {\n        if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError(\"Invalid argument\");\n        var i = 0;\n\n        for (var right = this.size - 1; right >= 1; right -= 2) {\n          if (right == 6) right = 5;\n\n          for (var vert = 0; vert < this.size; vert++) {\n            for (var j = 0; j < 2; j++) {\n              var x = right - j;\n              var upward = (right + 1 & 2) == 0;\n              var y = upward ? this.size - 1 - vert : vert;\n\n              if (!this.isFunction[y][x] && i < data.length * 8) {\n                this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                i++;\n              }\n            }\n          }\n        }\n\n        assert(i == data.length * 8);\n      } // XORs the codeword modules in this QR Code with the given mask pattern.\n      // The function modules must be marked and the codeword bits must be drawn\n      // before masking. Due to the arithmetic of XOR, calling applyMask() with\n      // the same mask value a second time will undo the mask. A final well-formed\n      // QR Code needs exactly one (not zero, two, etc.) mask applied.\n\n    }, {\n      key: \"applyMask\",\n      value: function applyMask(mask) {\n        if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n\n        for (var y = 0; y < this.size; y++) {\n          for (var x = 0; x < this.size; x++) {\n            var invert = void 0;\n\n            switch (mask) {\n              case 0:\n                invert = (x + y) % 2 == 0;\n                break;\n\n              case 1:\n                invert = y % 2 == 0;\n                break;\n\n              case 2:\n                invert = x % 3 == 0;\n                break;\n\n              case 3:\n                invert = (x + y) % 3 == 0;\n                break;\n\n              case 4:\n                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                break;\n\n              case 5:\n                invert = x * y % 2 + x * y % 3 == 0;\n                break;\n\n              case 6:\n                invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              case 7:\n                invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              default:\n                throw new Error(\"Unreachable\");\n            }\n\n            if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n          }\n        }\n      } // Calculates and returns the penalty score based on state of this QR Code's current modules.\n      // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\n    }, {\n      key: \"getPenaltyScore\",\n      value: function getPenaltyScore() {\n        var result = 0;\n\n        for (var y = 0; y < this.size; y++) {\n          var runColor = false;\n          var runX = 0;\n          var runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var x = 0; x < this.size; x++) {\n            if (this.modules[y][x] == runColor) {\n              runX++;\n              if (runX == 5) result += _QrCode.PENALTY_N1;else if (runX > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runX, runHistory);\n              if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n              runColor = this.modules[y][x];\n              runX = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _x = 0; _x < this.size; _x++) {\n          var _runColor = false;\n          var runY = 0;\n          var _runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var _y = 0; _y < this.size; _y++) {\n            if (this.modules[_y][_x] == _runColor) {\n              runY++;\n              if (runY == 5) result += _QrCode.PENALTY_N1;else if (runY > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runY, _runHistory);\n              if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * _QrCode.PENALTY_N3;\n              _runColor = this.modules[_y][_x];\n              runY = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _y2 = 0; _y2 < this.size - 1; _y2++) {\n          for (var _x2 = 0; _x2 < this.size - 1; _x2++) {\n            var color = this.modules[_y2][_x2];\n            if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += _QrCode.PENALTY_N2;\n          }\n        }\n\n        var dark = 0;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _row = _step3.value;\n            dark = _row.reduce(function (sum, color) {\n              return sum + (color ? 1 : 0);\n            }, dark);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var total = this.size * this.size;\n        var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n        assert(0 <= k && k <= 9);\n        result += k * _QrCode.PENALTY_N4;\n        assert(0 <= result && result <= 2568888);\n        return result;\n      }\n      /*-- Private helper functions --*/\n      // Returns an ascending list of positions of alignment patterns for this version number.\n      // Each position is in the range [0,177), and are used on both the x and y axes.\n      // This could be implemented as lookup table of 40 variable-length lists of integers.\n\n    }, {\n      key: \"getAlignmentPatternPositions\",\n      value: function getAlignmentPatternPositions() {\n        if (this.version == 1) return [];else {\n          var numAlign = Math.floor(this.version / 7) + 2;\n          var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n          var result = [6];\n\n          for (var pos = this.size - 7; result.length < numAlign; pos -= step) {\n            result.splice(1, 0, pos);\n          }\n\n          return result;\n        }\n      } // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n      // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n      // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\n    }, {\n      key: \"finderPenaltyCountPatterns\",\n      // Can only be called immediately after a light run is added, and\n      // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n      value: function finderPenaltyCountPatterns(runHistory) {\n        var n = runHistory[1];\n        assert(n <= this.size * 3);\n        var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n      } // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\n    }, {\n      key: \"finderPenaltyTerminateAndCount\",\n      value: function finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n        if (currentRunColor) {\n          this.finderPenaltyAddHistory(currentRunLength, runHistory);\n          currentRunLength = 0;\n        }\n\n        currentRunLength += this.size;\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        return this.finderPenaltyCountPatterns(runHistory);\n      } // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\n    }, {\n      key: \"finderPenaltyAddHistory\",\n      value: function finderPenaltyAddHistory(currentRunLength, runHistory) {\n        if (runHistory[0] == 0) currentRunLength += this.size;\n        runHistory.pop();\n        runHistory.unshift(currentRunLength);\n      }\n    }], [{\n      key: \"encodeText\",\n      value: function encodeText(text, ecl) {\n        var segs = qrcodegen2.QrSegment.makeSegments(text);\n        return _QrCode.encodeSegments(segs, ecl);\n      } // Returns a QR Code representing the given binary data at the given error correction level.\n      // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n      // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n      // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\n    }, {\n      key: \"encodeBinary\",\n      value: function encodeBinary(data, ecl) {\n        var seg = qrcodegen2.QrSegment.makeBytes(data);\n        return _QrCode.encodeSegments([seg], ecl);\n      }\n      /*-- Static factory functions (mid level) --*/\n      // Returns a QR Code representing the given segments with the given encoding parameters.\n      // The smallest possible QR Code version within the given range is automatically\n      // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n      // may be higher than the ecl argument if it can be done without increasing the\n      // version. The mask number is either between 0 to 7 (inclusive) to force that\n      // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n      // This function allows the user to create a custom sequence of segments that switches\n      // between modes (such as alphanumeric and byte) to encode text in less space.\n      // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n\n    }, {\n      key: \"encodeSegments\",\n      value: function encodeSegments(segs, ecl) {\n        var minVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var maxVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n        var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n        var boostEcl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError(\"Invalid value\");\n        var version;\n        var dataUsedBits;\n\n        for (version = minVersion;; version++) {\n          var dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n          var usedBits = QrSegment.getTotalBits(segs, version);\n\n          if (usedBits <= dataCapacityBits2) {\n            dataUsedBits = usedBits;\n            break;\n          }\n\n          if (version >= maxVersion) throw new RangeError(\"Data too long\");\n        }\n\n        for (var _i10 = 0, _arr = [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]; _i10 < _arr.length; _i10++) {\n          var newEcl = _arr[_i10];\n          if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n        }\n\n        var bb = [];\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = segs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var seg = _step4.value;\n            appendBits(seg.mode.modeBits, 4, bb);\n            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = seg.getData()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var b = _step5.value;\n                bb.push(b);\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        assert(bb.length == dataUsedBits);\n        var dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n        assert(bb.length <= dataCapacityBits);\n        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n        appendBits(0, (8 - bb.length % 8) % 8, bb);\n        assert(bb.length % 8 == 0);\n\n        for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {\n          appendBits(padByte, 8, bb);\n        }\n\n        var dataCodewords = [];\n\n        while (dataCodewords.length * 8 < bb.length) {\n          dataCodewords.push(0);\n        }\n\n        bb.forEach(function (b, i) {\n          return dataCodewords[i >>> 3] |= b << 7 - (i & 7);\n        });\n        return new _QrCode(version, ecl, dataCodewords, mask);\n      }\n    }, {\n      key: \"getNumRawDataModules\",\n      value: function getNumRawDataModules(ver) {\n        if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError(\"Version number out of range\");\n        var result = (16 * ver + 128) * ver + 64;\n\n        if (ver >= 2) {\n          var numAlign = Math.floor(ver / 7) + 2;\n          result -= (25 * numAlign - 10) * numAlign - 55;\n          if (ver >= 7) result -= 36;\n        }\n\n        assert(208 <= result && result <= 29648);\n        return result;\n      } // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n      // QR Code of the given version number and error correction level, with remainder bits discarded.\n      // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\n    }, {\n      key: \"getNumDataCodewords\",\n      value: function getNumDataCodewords(ver, ecl) {\n        return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      } // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n      // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\n    }, {\n      key: \"reedSolomonComputeDivisor\",\n      value: function reedSolomonComputeDivisor(degree) {\n        if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n        var result = [];\n\n        for (var i = 0; i < degree - 1; i++) {\n          result.push(0);\n        }\n\n        result.push(1);\n        var root = 1;\n\n        for (var _i11 = 0; _i11 < degree; _i11++) {\n          for (var j = 0; j < result.length; j++) {\n            result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n            if (j + 1 < result.length) result[j] ^= result[j + 1];\n          }\n\n          root = _QrCode.reedSolomonMultiply(root, 2);\n        }\n\n        return result;\n      } // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\n    }, {\n      key: \"reedSolomonComputeRemainder\",\n      value: function reedSolomonComputeRemainder(data, divisor) {\n        var result = divisor.map(function (_) {\n          return 0;\n        });\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          var _loop2 = function _loop2() {\n            var b = _step6.value;\n            var factor = b ^ result.shift();\n            result.push(0);\n            divisor.forEach(function (coef, i) {\n              return result[i] ^= _QrCode.reedSolomonMultiply(coef, factor);\n            });\n          };\n\n          for (var _iterator6 = data[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            _loop2();\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        return result;\n      } // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n      // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n\n    }, {\n      key: \"reedSolomonMultiply\",\n      value: function reedSolomonMultiply(x, y) {\n        if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError(\"Byte out of range\");\n        var z = 0;\n\n        for (var i = 7; i >= 0; i--) {\n          z = z << 1 ^ (z >>> 7) * 285;\n          z ^= (y >>> i & 1) * x;\n        }\n\n        assert(z >>> 8 == 0);\n        return z;\n      }\n    }]);\n\n    return _QrCode;\n  }();\n  /*-- Constants and tables --*/\n  // The minimum version number supported in the QR Code Model 2 standard.\n\n\n  _QrCode.MIN_VERSION = 1; // The maximum version number supported in the QR Code Model 2 standard.\n\n  _QrCode.MAX_VERSION = 40; // For use in getPenaltyScore(), when evaluating which mask is best.\n\n  _QrCode.PENALTY_N1 = 3;\n  _QrCode.PENALTY_N2 = 3;\n  _QrCode.PENALTY_N3 = 40;\n  _QrCode.PENALTY_N4 = 10;\n  _QrCode.ECC_CODEWORDS_PER_BLOCK = [// Version: (note that index 0 is for padding, and is set to an illegal value)\n  //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Low\n  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], // Medium\n  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Quartile\n  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] // High\n  ];\n  _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [// Version: (note that index 0 is for padding, and is set to an illegal value)\n  //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], // Low\n  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], // Medium\n  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], // Quartile\n  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] // High\n  ];\n  var QrCode = _QrCode;\n  qrcodegen2.QrCode = _QrCode;\n\n  function appendBits(val, len, bb) {\n    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError(\"Value out of range\");\n\n    for (var i = len - 1; i >= 0; i--) {\n      bb.push(val >>> i & 1);\n    }\n  }\n\n  function getBit(x, i) {\n    return (x >>> i & 1) != 0;\n  }\n\n  function assert(cond) {\n    if (!cond) throw new Error(\"Assertion error\");\n  }\n\n  var _QrSegment =\n  /*#__PURE__*/\n  function () {\n    /*-- Constructor (low level) and fields --*/\n    // Creates a new QR Code segment with the given attributes and data.\n    // The character count (numChars) must agree with the mode and the bit buffer length,\n    // but the constraint isn't checked. The given bit buffer is cloned and stored.\n    function _QrSegment(mode, numChars, bitData) {\n      _classCallCheck(this, _QrSegment);\n\n      this.mode = mode;\n      this.numChars = numChars;\n      this.bitData = bitData;\n      if (numChars < 0) throw new RangeError(\"Invalid argument\");\n      this.bitData = bitData.slice();\n    }\n    /*-- Static factory functions (mid level) --*/\n    // Returns a segment representing the given binary data encoded in\n    // byte mode. All input byte arrays are acceptable. Any text string\n    // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n\n\n    _createClass(_QrSegment, [{\n      key: \"getData\",\n\n      /*-- Methods --*/\n      // Returns a new copy of the data bits of this segment.\n      value: function getData() {\n        return this.bitData.slice();\n      } // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n      // the given version. The result is infinity if a segment has too many characters to fit its length field.\n\n    }], [{\n      key: \"makeBytes\",\n      value: function makeBytes(data) {\n        var bb = [];\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = data[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var b = _step7.value;\n            appendBits(b, 8, bb);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n\n        return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n      } // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n\n    }, {\n      key: \"makeNumeric\",\n      value: function makeNumeric(digits) {\n        if (!_QrSegment.isNumeric(digits)) throw new RangeError(\"String contains non-numeric characters\");\n        var bb = [];\n\n        for (var i = 0; i < digits.length;) {\n          var n = Math.min(digits.length - i, 3);\n          appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n          i += n;\n        }\n\n        return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n      } // Returns a segment representing the given text string encoded in alphanumeric mode.\n      // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n      // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\n    }, {\n      key: \"makeAlphanumeric\",\n      value: function makeAlphanumeric(text) {\n        if (!_QrSegment.isAlphanumeric(text)) throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n        var bb = [];\n        var i;\n\n        for (i = 0; i + 2 <= text.length; i += 2) {\n          var temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n          temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n          appendBits(temp, 11, bb);\n        }\n\n        if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n        return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n      } // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n      // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\n    }, {\n      key: \"makeSegments\",\n      value: function makeSegments(text) {\n        if (text == \"\") return [];else if (_QrSegment.isNumeric(text)) return [_QrSegment.makeNumeric(text)];else if (_QrSegment.isAlphanumeric(text)) return [_QrSegment.makeAlphanumeric(text)];else return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];\n      } // Returns a segment representing an Extended Channel Interpretation\n      // (ECI) designator with the given assignment value.\n\n    }, {\n      key: \"makeEci\",\n      value: function makeEci(assignVal) {\n        var bb = [];\n        if (assignVal < 0) throw new RangeError(\"ECI assignment value out of range\");else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {\n          appendBits(2, 2, bb);\n          appendBits(assignVal, 14, bb);\n        } else if (assignVal < 1e6) {\n          appendBits(6, 3, bb);\n          appendBits(assignVal, 21, bb);\n        } else throw new RangeError(\"ECI assignment value out of range\");\n        return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n      } // Tests whether the given string can be encoded as a segment in numeric mode.\n      // A string is encodable iff each character is in the range 0 to 9.\n\n    }, {\n      key: \"isNumeric\",\n      value: function isNumeric(text) {\n        return _QrSegment.NUMERIC_REGEX.test(text);\n      } // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n      // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n      // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\n    }, {\n      key: \"isAlphanumeric\",\n      value: function isAlphanumeric(text) {\n        return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n      }\n    }, {\n      key: \"getTotalBits\",\n      value: function getTotalBits(segs, version) {\n        var result = 0;\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = segs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var seg = _step8.value;\n            var ccbits = seg.mode.numCharCountBits(version);\n            if (seg.numChars >= 1 << ccbits) return Infinity;\n            result += 4 + ccbits + seg.bitData.length;\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        return result;\n      } // Returns a new array of bytes representing the given string encoded in UTF-8.\n\n    }, {\n      key: \"toUtf8ByteArray\",\n      value: function toUtf8ByteArray(str) {\n        str = encodeURI(str);\n        var result = [];\n\n        for (var i = 0; i < str.length; i++) {\n          if (str.charAt(i) != \"%\") result.push(str.charCodeAt(i));else {\n            result.push(parseInt(str.substring(i + 1, i + 3), 16));\n            i += 2;\n          }\n        }\n\n        return result;\n      }\n    }]);\n\n    return _QrSegment;\n  }();\n  /*-- Constants --*/\n  // Describes precisely all strings that are encodable in numeric mode.\n\n\n  _QrSegment.NUMERIC_REGEX = /^[0-9]*$/; // Describes precisely all strings that are encodable in alphanumeric mode.\n\n  _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/; // The set of all legal characters in alphanumeric mode,\n  // where each character value maps to the index in the string.\n\n  _QrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n  var QrSegment = _QrSegment;\n  qrcodegen2.QrSegment = _QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrCode;\n\n  (function (QrCode2) {\n    var _Ecc = // The QR Code can tolerate about 30% erroneous codewords\n\n    /*-- Constructor and fields --*/\n    function _Ecc(ordinal, formatBits) {\n      _classCallCheck(this, _Ecc);\n\n      this.ordinal = ordinal;\n      this.formatBits = formatBits;\n    };\n    /*-- Constants --*/\n\n\n    _Ecc.LOW = new _Ecc(0, 1); // The QR Code can tolerate about  7% erroneous codewords\n\n    _Ecc.MEDIUM = new _Ecc(1, 0); // The QR Code can tolerate about 15% erroneous codewords\n\n    _Ecc.QUARTILE = new _Ecc(2, 3); // The QR Code can tolerate about 25% erroneous codewords\n\n    _Ecc.HIGH = new _Ecc(3, 2);\n    var Ecc = _Ecc;\n    QrCode2.Ecc = _Ecc;\n  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrSegment;\n\n  (function (QrSegment2) {\n    var _Mode =\n    /*#__PURE__*/\n    function () {\n      /*-- Constructor and fields --*/\n      function _Mode(modeBits, numBitsCharCount) {\n        _classCallCheck(this, _Mode);\n\n        this.modeBits = modeBits;\n        this.numBitsCharCount = numBitsCharCount;\n      }\n      /*-- Method --*/\n      // (Package-private) Returns the bit width of the character count field for a segment in\n      // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n\n\n      _createClass(_Mode, [{\n        key: \"numCharCountBits\",\n        value: function numCharCountBits(ver) {\n          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n        }\n      }]);\n\n      return _Mode;\n    }();\n    /*-- Constants --*/\n\n\n    _Mode.NUMERIC = new _Mode(1, [10, 12, 14]);\n    _Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);\n    _Mode.BYTE = new _Mode(4, [8, 16, 16]);\n    _Mode.KANJI = new _Mode(8, [8, 10, 12]);\n    _Mode.ECI = new _Mode(7, [0, 0, 0]);\n    var Mode = _Mode;\n    QrSegment2.Mode = _Mode;\n  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\n\nvar qrcodegen_default = qrcodegen; // src/index.tsx\n\n/**\n * @license qrcode.react\n * Copyright (c) Paul O'Shannessy\n * SPDX-License-Identifier: ISC\n */\n\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen_default.QrCode.Ecc.LOW,\n  M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n  H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = \"L\";\nvar DEFAULT_BGCOLOR = \"#FFFFFF\";\nvar DEFAULT_FGCOLOR = \"#000000\";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar DEFAULT_MINVERSION = 1;\nvar SPEC_MARGIN_SIZE = 4;\nvar DEFAULT_MARGIN_SIZE = 0;\nvar DEFAULT_IMG_SCALE = 0.1;\n\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        ops.push(\"M\".concat(start + margin, \" \").concat(y + margin, \"h\").concat(x - start, \"v1H\").concat(start + margin, \"z\"));\n        start = null;\n        return;\n      }\n\n      if (x === row.length - 1) {\n        if (!cell) {\n          return;\n        }\n\n        if (start === null) {\n          ops.push(\"M\".concat(x + margin, \",\").concat(y + margin, \" h1v1H\").concat(x + margin, \"z\"));\n        } else {\n          ops.push(\"M\".concat(start + margin, \",\").concat(y + margin, \" h\").concat(x + 1 - start, \"v1H\").concat(start + margin, \"z\"));\n        }\n\n        return;\n      }\n\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join(\"\");\n}\n\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n\n      return false;\n    });\n  });\n}\n\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;\n  var excavation = null;\n\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n\n  var crossOrigin = imageSettings.crossOrigin;\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation,\n    opacity: opacity,\n    crossOrigin: crossOrigin\n  };\n}\n\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.max(Math.floor(marginSize), 0);\n  }\n\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n\nfunction useQRCode(_ref) {\n  var value = _ref.value,\n      level = _ref.level,\n      minVersion = _ref.minVersion,\n      includeMargin = _ref.includeMargin,\n      marginSize = _ref.marginSize,\n      imageSettings = _ref.imageSettings,\n      size = _ref.size,\n      boostLevel = _ref.boostLevel;\n  var qrcode = React.useMemo(function () {\n    var values = Array.isArray(value) ? value : [value];\n    var segments = values.reduce(function (accum, v) {\n      accum.push.apply(accum, _toConsumableArray(qrcodegen_default.QrSegment.makeSegments(v)));\n      return accum;\n    }, []);\n    return qrcodegen_default.QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);\n  }, [value, level, minVersion, boostLevel]);\n\n  var _React$useMemo = React.useMemo(function () {\n    var cells2 = qrcode.getModules();\n    var margin2 = getMarginSize(includeMargin, marginSize);\n    var numCells2 = cells2.length + margin2 * 2;\n    var calculatedImageSettings2 = getImageSettings(cells2, size, margin2, imageSettings);\n    return {\n      cells: cells2,\n      margin: margin2,\n      numCells: numCells2,\n      calculatedImageSettings: calculatedImageSettings2\n    };\n  }, [qrcode, size, imageSettings, includeMargin, marginSize]),\n      cells = _React$useMemo.cells,\n      margin = _React$useMemo.margin,\n      numCells = _React$useMemo.numCells,\n      calculatedImageSettings = _React$useMemo.calculatedImageSettings;\n\n  return {\n    qrcode: qrcode,\n    margin: margin,\n    cells: cells,\n    numCells: numCells,\n    calculatedImageSettings: calculatedImageSettings\n  };\n}\n\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}();\n\nvar QRCodeCanvas = React.forwardRef(function QRCodeCanvas2(props, forwardedRef) {\n  var _a = props,\n      value = _a.value,\n      _a$size = _a.size,\n      size = _a$size === void 0 ? DEFAULT_SIZE : _a$size,\n      _a$level = _a.level,\n      level = _a$level === void 0 ? DEFAULT_LEVEL : _a$level,\n      _a$bgColor = _a.bgColor,\n      bgColor = _a$bgColor === void 0 ? DEFAULT_BGCOLOR : _a$bgColor,\n      _a$fgColor = _a.fgColor,\n      fgColor = _a$fgColor === void 0 ? DEFAULT_FGCOLOR : _a$fgColor,\n      _a$includeMargin = _a.includeMargin,\n      includeMargin = _a$includeMargin === void 0 ? DEFAULT_INCLUDEMARGIN : _a$includeMargin,\n      _a$minVersion = _a.minVersion,\n      minVersion = _a$minVersion === void 0 ? DEFAULT_MINVERSION : _a$minVersion,\n      boostLevel = _a.boostLevel,\n      marginSize = _a.marginSize,\n      imageSettings = _a.imageSettings,\n      extraProps = __objRest(_a, [\"value\", \"size\", \"level\", \"bgColor\", \"fgColor\", \"includeMargin\", \"minVersion\", \"boostLevel\", \"marginSize\", \"imageSettings\"]);\n\n  var _b = extraProps,\n      style = _b.style,\n      otherProps = __objRest(_b, [\"style\"]);\n\n  var imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n\n  var _canvas = React.useRef(null);\n\n  var _image = React.useRef(null);\n\n  var setCanvasRef = React.useCallback(function (node) {\n    _canvas.current = node;\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(node);\n    } else if (forwardedRef) {\n      forwardedRef.current = node;\n    }\n  }, [forwardedRef]);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      isImgLoaded = _React$useState2[0],\n      setIsImageLoaded = _React$useState2[1];\n\n  var _useQRCode = useQRCode({\n    value: value,\n    level: level,\n    minVersion: minVersion,\n    boostLevel: boostLevel,\n    includeMargin: includeMargin,\n    marginSize: marginSize,\n    imageSettings: imageSettings,\n    size: size\n  }),\n      margin = _useQRCode.margin,\n      cells = _useQRCode.cells,\n      numCells = _useQRCode.numCells,\n      calculatedImageSettings = _useQRCode.calculatedImageSettings;\n\n  React.useEffect(function () {\n    if (_canvas.current != null) {\n      var canvas = _canvas.current;\n      var ctx = canvas.getContext(\"2d\");\n\n      if (!ctx) {\n        return;\n      }\n\n      var cellsToDraw = cells;\n      var image = _image.current;\n      var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n\n      if (haveImageToRender) {\n        if (calculatedImageSettings.excavation != null) {\n          cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n      }\n\n      var pixelRatio = window.devicePixelRatio || 1;\n      canvas.height = canvas.width = size * pixelRatio;\n      var scale = size / numCells * pixelRatio;\n      ctx.scale(scale, scale);\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(0, 0, numCells, numCells);\n      ctx.fillStyle = fgColor;\n\n      if (SUPPORTS_PATH2D) {\n        ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));\n      } else {\n        cells.forEach(function (row, rdx) {\n          row.forEach(function (cell, cdx) {\n            if (cell) {\n              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n            }\n          });\n        });\n      }\n\n      if (calculatedImageSettings) {\n        ctx.globalAlpha = calculatedImageSettings.opacity;\n      }\n\n      if (haveImageToRender) {\n        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n      }\n    }\n  });\n  React.useEffect(function () {\n    setIsImageLoaded(false);\n  }, [imgSrc]);\n\n  var canvasStyle = __spreadValues({\n    height: size,\n    width: size\n  }, style);\n\n  var img = null;\n\n  if (imgSrc != null) {\n    img =\n    /* @__PURE__ */\n    React.createElement(\"img\", {\n      src: imgSrc,\n      key: imgSrc,\n      style: {\n        display: \"none\"\n      },\n      onLoad: function onLoad() {\n        setIsImageLoaded(true);\n      },\n      ref: _image,\n      crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin\n    });\n  }\n\n  return (\n    /* @__PURE__ */\n    React.createElement(React.Fragment, null,\n    /* @__PURE__ */\n    React.createElement(\"canvas\", __spreadValues({\n      style: canvasStyle,\n      height: size,\n      width: size,\n      ref: setCanvasRef,\n      role: \"img\"\n    }, otherProps)), img)\n  );\n});\nQRCodeCanvas.displayName = \"QRCodeCanvas\";\nvar QRCodeSVG = React.forwardRef(function QRCodeSVG2(props, forwardedRef) {\n  var _a = props,\n      value = _a.value,\n      _a$size2 = _a.size,\n      size = _a$size2 === void 0 ? DEFAULT_SIZE : _a$size2,\n      _a$level2 = _a.level,\n      level = _a$level2 === void 0 ? DEFAULT_LEVEL : _a$level2,\n      _a$bgColor2 = _a.bgColor,\n      bgColor = _a$bgColor2 === void 0 ? DEFAULT_BGCOLOR : _a$bgColor2,\n      _a$fgColor2 = _a.fgColor,\n      fgColor = _a$fgColor2 === void 0 ? DEFAULT_FGCOLOR : _a$fgColor2,\n      _a$includeMargin2 = _a.includeMargin,\n      includeMargin = _a$includeMargin2 === void 0 ? DEFAULT_INCLUDEMARGIN : _a$includeMargin2,\n      _a$minVersion2 = _a.minVersion,\n      minVersion = _a$minVersion2 === void 0 ? DEFAULT_MINVERSION : _a$minVersion2,\n      boostLevel = _a.boostLevel,\n      title = _a.title,\n      marginSize = _a.marginSize,\n      imageSettings = _a.imageSettings,\n      otherProps = __objRest(_a, [\"value\", \"size\", \"level\", \"bgColor\", \"fgColor\", \"includeMargin\", \"minVersion\", \"boostLevel\", \"title\", \"marginSize\", \"imageSettings\"]);\n\n  var _useQRCode2 = useQRCode({\n    value: value,\n    level: level,\n    minVersion: minVersion,\n    boostLevel: boostLevel,\n    includeMargin: includeMargin,\n    marginSize: marginSize,\n    imageSettings: imageSettings,\n    size: size\n  }),\n      margin = _useQRCode2.margin,\n      cells = _useQRCode2.cells,\n      numCells = _useQRCode2.numCells,\n      calculatedImageSettings = _useQRCode2.calculatedImageSettings;\n\n  var cellsToDraw = cells;\n  var image = null;\n\n  if (imageSettings != null && calculatedImageSettings != null) {\n    if (calculatedImageSettings.excavation != null) {\n      cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);\n    }\n\n    image =\n    /* @__PURE__ */\n    React.createElement(\"image\", {\n      href: imageSettings.src,\n      height: calculatedImageSettings.h,\n      width: calculatedImageSettings.w,\n      x: calculatedImageSettings.x + margin,\n      y: calculatedImageSettings.y + margin,\n      preserveAspectRatio: \"none\",\n      opacity: calculatedImageSettings.opacity,\n      crossOrigin: calculatedImageSettings.crossOrigin\n    });\n  }\n\n  var fgPath = generatePath(cellsToDraw, margin);\n  return (\n    /* @__PURE__ */\n    React.createElement(\"svg\", __spreadValues({\n      height: size,\n      width: size,\n      viewBox: \"0 0 \".concat(numCells, \" \").concat(numCells),\n      ref: forwardedRef,\n      role: \"img\"\n    }, otherProps), !!title &&\n    /* @__PURE__ */\n    React.createElement(\"title\", null, title),\n    /* @__PURE__ */\n    React.createElement(\"path\", {\n      fill: bgColor,\n      d: \"M0,0 h\".concat(numCells, \"v\").concat(numCells, \"H0z\"),\n      shapeRendering: \"crispEdges\"\n    }),\n    /* @__PURE__ */\n    React.createElement(\"path\", {\n      fill: fgColor,\n      d: fgPath,\n      shapeRendering: \"crispEdges\"\n    }), image)\n  );\n});\nQRCodeSVG.displayName = \"QRCodeSVG\";\nexport { QRCodeCanvas, QRCodeSVG };","map":null,"metadata":{},"sourceType":"module"}